[{"id":"f961bb942d7e1f4fc29054a4a438aa31","title":"ojWeek4","content":"\n\n\n\n\n\n\n\n\n\n\nT1: Acesrc’s Bizarre Adventure题目描述 ： 在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc,解决下面的问题:在一个二维平面上，有N个红色的点和N个蓝色的点。其中第i个红色的点的坐标是 (ai,bi) ,第i和蓝色点的坐标为 (ci,di).Acesrc每次可以选择平面上一个红色的点和一个蓝色的点，如果这两个点满足红色的点的x坐标小于蓝色的点的x坐标，且红色的点的y坐标小于蓝色的点的y坐标. 那么Acesrc就可以同时将这两个点从平面上移除，并发动一次秘技·波纹疾走。现在Acesrc想要知道，对于给定的一共2N个点和它们各自的坐标，他最多可以发动几次秘技·波纹疾走?1 &lt;= N &lt;= 100\n\n\n\n\n\n\n\n\n\n题目分析： 这道题看起来是一道典型的最大二分匹配的题，需要利用本周问题求解课程的网络流算法即首先分成两个集合，然后把能连的边连上（秘技），然后权值为1，跑一次最大流算法即可。此处可以参考oi-wiki所给出的dinic算法的实现worst-case的时间复杂度为O(V2 E), 是可以接受的.特别的，对于二分图匹配的复杂度为O(E V1/2)\n\nClick to see source code\nAC代码如下：\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define maxn 250\n#define INF 0x3f3f3f3f\n\nstruct Edge &#123;\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  int n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;int&gt; G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) &#123;\n    for (int i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(int from, int to, int cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;int&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (int i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  int DFS(int x, int a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    int flow &#x3D; 0, f;\n    for (int&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n  int Maxflow(int s, int t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    int flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;\n\nstruct point&#123;\n\tint x,y;\n&#125;R[105],B[105];\n\nint main()&#123;\n\tint N;\n\tcin&gt;&gt;N;\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tcin&gt;&gt;R[i].x;\n\t\tcin&gt;&gt;R[i].y;\n\t&#125;\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tcin&gt;&gt;B[i].x;\n\t\tcin&gt;&gt;B[i].y;\n\t&#125;\n\t\n\tDinic ans;\n\tans.init(N*2+2);\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tans.AddEdge(0,i,1);\t\n\t\tfor(int j &#x3D; 1;j&lt;&#x3D;N;++j)\n\t\t\tif(R[i].x&lt;B[j].x&amp;&amp;R[i].y&lt;B[j].y)\n\t\t\t\tans.AddEdge(i,j+N,1);\n\t&#125;\n\tfor(int i &#x3D; N+1;i&lt;&#x3D;2*N;++i)&#123;\n\t\tans.AddEdge(i,N*2+1,1);\n\t&#125;\t\n\tcout&lt;&lt;ans.Maxflow(0,N*2+1);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT2: Acesrc Doesn’t Want To Bite The Dust在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc解决下面的问题:Acesrc得到了n个二次函数，其中第i个二次函数是fi(x)=aix2+bix+cixi的取值范围为li&lt;=xi&lt;=ri，xi为整数除此之外Acesrc还受到了m个限制,每个限制都是形如xu&lt;=xv+d的形式，其中u和v是不同函数的编号，d是一个整数Acesrc需要知道在这样的限制下所有函数的和的最大值为多少，如果失败会得到“败者食尘”的惩罚，你能帮帮他吗？\n\n\n\n\n\n\n\n\n\n题目分析：据大佬所说，yjh开始放oi省选难度的题了，就很离谱。（这题做了很长时间，很恶心）ri-li的范围为0-200，n最大为50，如果直接莽着表示流的话肯定会炸。网络流问题的难点也恰好在建模上，提示是使用最小割的思想。我们考虑一种神奇的构造方式，首先考虑s和t作为源头和最后的节点，对于每一个函数我们考虑x所有可取的点，连接s与最小的那个以及最大的那个与t，并把中间的按从小到大的顺序连接，权值设为一个bias-f值，（因为最小割求最大-&gt;取负，为了计算方便加上一个bias），如果没有m个限制的话，此时我们可以直接通过运行最大流算法得到最小割值，这是显然的。如果加上m个限制呢，首先说明，从s到t的一条路表示的是可以走的，因此当给出一个xu&lt;=xv+d的限制的时候，我们可以通过判断xu中所有可行的x值所能连接到的xv所形成的path而这样连接所形成的边是不可被割的，所以赋值INF，即可以通过最小割完成计算。\n\nClick to see source code\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define bias 1000005\n#define maxn 5005\n#define INF 1e9\n#define MAX_V 100005\nstruct Edge &#123;\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  int n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;int&gt; G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) &#123;\n    for (int i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(int from, int to, int cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;int&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (int i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  int DFS(int x, int a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    int flow &#x3D; 0, f;\n    for (int&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n  int Maxflow(int s, int t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    int flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;\n\nstruct f&#123;\n\tint a,b,c;\n&#125;ft[55];\nvector&lt; int &gt; pts[55];\n\nint u,v,w;\nint main()&#123;\n\tDinic ans;\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tint T &#x3D; n;\n\twhile(T--)&#123;\n\t\tcin&gt;&gt;u&gt;&gt;v&gt;&gt;w;\n\t\tf tmp; tmp.a&#x3D;u,tmp.b&#x3D;v,tmp.c&#x3D;w;\n\t\tft[n-T] &#x3D; tmp;\n\t&#125;\n\tT &#x3D; n;\n\tint s &#x3D; 1,t &#x3D; 2,l &#x3D; 1;\n\tint cnt &#x3D; 3;\n\twhile(T--)&#123;\n\t\tcin&gt;&gt;u&gt;&gt;v;\n\t\tl &#x3D; 1;\n\t\tpts[n-T].push_back(u);\n\t\tpts[n-T].push_back(1);\n\t\tfor(int i &#x3D; u;i&lt;v;++i)&#123;\n\t\t\tpts[n-T].push_back(cnt);\n\t\t\tans.AddEdge(l,cnt,bias-ft[n-T].a*i*i-ft[n-T].b*i-ft[n-T].c);\n\t\t\tl &#x3D; cnt;\n\t\t\tcnt++;\n\t\t&#125;\n\t\tans.AddEdge(l,t,bias-ft[n-T].a*v*v-ft[n-T].b*v-ft[n-T].c);\n\t\tpts[n-T].push_back(cnt++);\n\t&#125;\n\tcnt--;\n\tT &#x3D; m;\n\twhile(T--)&#123;\n\t\tcin&gt;&gt;u&gt;&gt;v&gt;&gt;w;\n\t\tint start1 &#x3D; pts[u][0];\n\t\tint start2 &#x3D; pts[v][0];\n\t\tint len1 &#x3D; pts[u].size()-2;\n\t\tint len2 &#x3D; pts[v].size()-2;\n\t\tfor(int i &#x3D; 0;i&lt;len1;++i)&#123;\n\t\t\t\tif(start1+i&gt;start2+w)&#123;\n\t\t\t\t\tif(start1+i&gt;start2+w+len2-1)\tans.AddEdge(pts[u][i+1],t,INF);\n\t\t\t\t\telse \tans.AddEdge(pts[u][i+1],pts[v][start1+i-w-start2+1],INF);\n\t\t\t\t&#x2F;&#x2F;\tcout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;&quot; &quot;&lt;&lt;pts[u][i]&lt;&lt;endl;\n\t\t\t\t&#125;\t\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;,n*bias-ans.Maxflow(1,2));\n\t\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nT3 最小化现在有n个只能取值为-W或W的变量w1,w2….wn, 你现在需要给这n个变量赋值，使得在满足一定限制的情况下目标函数最小。目标函数：有p个九元组(xi，yi,zi,ai,bi,ci,di,ei,fi)。定义第i个部分代价函数Hi为：Hi = ai |wxi-wyi|+bi |wyi-wzi|+ci |wzi-wxi|+di (wxi-wyi)+ei (wyi-wzi)+fi (wzi-wxi)目标函数为O(w1,w2….wn) = w1+w2+….+wn+H1+H2+….+Hn一共有q个限制，以三元组(xi,yi,ri)的形式给出：若ri = 0， 则wxi &lt;= wyi若ri = 1， 则wxi = wyi若ri = 2， 则wxi &lt; wyi\n\n\n\n\n\n\n\n\n\n题目分析：什么机器学习问题…（最小化函数，正则化）言归正传，首先这题有多个数据点所以重新用dinic的时候不要忘了init。和T2比较类似的都是有限制条件，所以可以想到用同样的方法进行最小割。 与T2不同的是这题的边的权值不好确定考虑到w只能取+W和-W，那么其实只需要变成两个点然后中间连一条INF的边即可。\n\nClick to see source code\nAC代码如下：\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define bias 100000005\n#define maxn 5005\n#define INF LLONG_MAX\n#define MAX_V 100005\nstruct Edge &#123;\n  ll from, to, cap, flow;\n  Edge(ll u, ll v, ll c, ll f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  ll n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;ll&gt; G[maxn];\n  ll d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(ll n) &#123;\n    for (ll i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(ll from, ll to, ll cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;ll&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (ll i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  ll DFS(ll x, ll a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    ll flow &#x3D; 0, f;\n    for (ll&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n ll Maxflow(ll s, ll t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    ll flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;Dinic ans;\nll pt[11451],ng[11451];\nvoid solve()&#123;\n\t\n\tll n,W,p,q;\n\t\tcin&gt;&gt;n&gt;&gt;W&gt;&gt;p&gt;&gt;q;\n\t\tfor(ll i &#x3D; 1;i&lt;&#x3D;n;++i) pt[i]&#x3D;1,ng[i]&#x3D;-1;\n\t\tll s &#x3D;0 ,t &#x3D;2*n+1; \n\t\tans.init(2*n+2);\n\t\tfor(ll i&#x3D;1;i&lt;&#x3D;p;++i)&#123;\n\t\t\tll x,y,z,a,b,c,d,e,f;\n\t\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;\n\t\t\tpt[x]+&#x3D;(d-f); pt[y]+&#x3D;(e-d);pt[z]+&#x3D;(-e+f);\n\t\t\tng[x]-&#x3D;(d-f); ng[y]-&#x3D;(e-d);ng[z]-&#x3D;(-e+f);\n\t\t\tans.AddEdge(x,n+y,2*a);ans.AddEdge(y,n+x,2*a);\n\t\t\tans.AddEdge(y,n+z,2*b);ans.AddEdge(z,n+y,2*b);\n\t\t\tans.AddEdge(x,n+z,2*c);ans.AddEdge(z,n+x,2*c);\n\t\t&#125;\n\t\tfor(ll i&#x3D;1;i&lt;&#x3D;q;++i)&#123;\n\t\tll a,b,type;\n\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;type;\n\t\tif(type&#x3D;&#x3D;0) ans.AddEdge(a,b+n,INF);\n\t\tif(type&#x3D;&#x3D;1) ans.AddEdge(a,b+n,INF),ans.AddEdge(b,a+n,INF);\n\t\tif(type&#x3D;&#x3D;2) ans.AddEdge(a,t,INF),ans.AddEdge(s,b+n,INF);\n\t\t&#125;\n\t\tfor(ll i &#x3D;1;i&lt;&#x3D;n;++i)&#123;\n\t\t\tans.AddEdge(s,i,ng[i]+bias);\n\t\t\tans.AddEdge(i,i+n,INF);\n\t\t\tans.AddEdge(i+n,t,pt[i]+bias);\n\t\t&#125;\n\t\tprintf(&quot;%lld\\n&quot;,W*(ans.Maxflow(0,2*n+1)-n*bias));\n&#125;\n\nint main()&#123;\n\tint T;\n\tcin&gt;&gt;T;\n\twhile(T--)&#123;\n\t\tsolve();\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n","slug":"ojWeek4","date":"2021-10-03T11:03:41.000Z","categories_index":"算法,OJ,网络流","tags_index":"网络流算法","author_index":"CT Wang"},{"id":"432e55ae1810d65c004161da271a9110","title":"被我忽悠着写博客的大佬的网站也建立好了～","content":"\n\n\n\n\n\n\n\n\n/撒花/撒花/撒花\n一个大佬的站点刚刚建立，大家快去康康\n","slug":"congra","date":"2021-10-03T06:49:12.000Z","categories_index":"","tags_index":"友站信息","author_index":"CT Wang"},{"id":"4b90cd80f00a704a2726658058c8f1d8","title":"日更吐槽","content":"\n\n\n\n\n\n\n\n\n10.2今日csapp看到进程相关的内容，里面有意思的一点是内核发送信号给进程的时候，同一种类型只会有一个pending signal，当一个新的pending signal被传来的时候，当前的pending signal就会被简单的丢弃掉。 也就是当你在做手头的东西的时候（用户模式），传来了处理紧急ddl的信号（异常响应，还未处理，属于pending状态），如果此时出现了另一个ddl（又一个pending-signal），你的第一个ddl会被错过（丢弃）。 (过于常见了属于是)\n\n\n\n\n\n\n\n\n\n10.3尝试加入访客ip的功能，意料之中的失败了 呜呜\n","slug":"daily-updated","date":"2021-10-02T12:15:52.000Z","categories_index":"","tags_index":"daily","author_index":"CT Wang"},{"id":"2f23fe7ba0abdac5dd935a1b552d8d91","title":"并不知道写什么反正先拿来测试的blog","content":"哈哈，放这个blog莫名其妙把首页的给顶下来了 吐了\n\n\n\n\n\n\n\n\n\n10.2 5:07 pm发现了从后面几个分区互相切换会出bug，暂时可以通过像先从友链分区回主页再进比如手写笔记分区这样的方式解决(已通过改绝对路径解决，可以正常使用了)\n\n\n\n\n\n\n\n\n\n10.2 5.11 pm添加手动播放bgm功能，等学会自动播放后会添加进各个blog里（目前只会手动bgm\n\n\n\n\n\n\n\n\n\n\n\n预告一下，想在blog里实现账号注册与评论的功能，但是可能得先去看一点后端的东西，先鸽着争取十一结束前发布第一个技术型博客文，可能是这周的问求的网络流算法之类的（万一ddl赶不完就鸽掉求一波网站收藏呜呜\n","slug":"My-first-blog","date":"2021-10-02T08:27:55.000Z","categories_index":"","tags_index":"“useless”","author_index":"CT Wang"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"这是第一次使用hexo在Github上建立个人blog，使用的是一个叫Aurora的主题，对这方面完全不懂所以可能经常会鸽功能。\n最近在做ics课的pa所以等课程结束会把实验日志挂上来，应该还是很有意思的（由于学术诚信问题不能现在直接挂上\n\n\n\n\n\n\n\n\n\n这是PA网站：https://nju-projectn.github.io/ics-pa-gitbook/ics2021/\n每周问题求解课程的OJ题我会尽量把题解放上来，因为很多时候不写出来其实自己也有点一知半解的。\n不定期分享恰饭照片\n（等攒够钱一定买域名挂上来解决GitHub访问慢的问题，敬请期待）\n","slug":"hello-world","date":"2021-10-02T07:34:55.000Z","categories_index":"","tags_index":"基础说明","author_index":"CT Wang"}]