[{"id":"dcd93922bbcab94a89907eb57bacec11","title":"ojWeek3","content":"\n\n\n\n\n\n\n\n\nT1: Acesrc’s Bizarre Adventure题目描述 ： 在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc,解决下面的问题:在一个二维平面上，有N个红色的点和N个蓝色的点。其中第i个红色的点的坐标是 (ai,bi) ,第i和蓝色点的坐标为 (ci,di).Acesrc每次可以选择平面上一个红色的点和一个蓝色的点，如果这两个点满足红色的点的x坐标小于蓝色的点的x坐标，且红色的点的y坐标小于蓝色的点的y坐标. 那么Acesrc就可以同时将这两个点从平面上移除，并发动一次秘技·波纹疾走。现在Acesrc想要知道，对于给定的一共2N个点和它们各自的坐标，他最多可以发动几次秘技·波纹疾走?1 &lt;= N &lt;= 100\n\n\n\n\n\n\n\n\n\n题目分析： 这道题看起来是一道典型的最大二分匹配的题，需要利用本周问题求解课程的网络流算法即首先分成两个集合，然后把能连的边连上（秘技），然后权值为1，跑一次最大流算法即可。此处可以参考oi-wiki所给出的dinic算法的实现worst-case的时间复杂度为O(V2 E), 是可以接受的.特别的，对于二分图匹配的复杂度为O(E V1/2)\n\nClick to see more\nAC代码如下：\n#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define maxn 250\n#define INF 0x3f3f3f3f\n\nstruct Edge &#123;\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  int n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;int&gt; G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) &#123;\n    for (int i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(int from, int to, int cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;int&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (int i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  int DFS(int x, int a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    int flow &#x3D; 0, f;\n    for (int&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n  int Maxflow(int s, int t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    int flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;\n\nstruct point&#123;\n\tint x,y;\n&#125;R[105],B[105];\n\nint main()&#123;\n\tint N;\n\tcin&gt;&gt;N;\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tcin&gt;&gt;R[i].x;\n\t\tcin&gt;&gt;R[i].y;\n\t&#125;\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tcin&gt;&gt;B[i].x;\n\t\tcin&gt;&gt;B[i].y;\n\t&#125;\n\t\n\tDinic ans;\n\tans.init(N*2+2);\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tans.AddEdge(0,i,1);\t\n\t\tfor(int j &#x3D; 1;j&lt;&#x3D;N;++j)\n\t\t\tif(R[i].x&lt;B[j].x&amp;&amp;R[i].y&lt;B[j].y)\n\t\t\t\tans.AddEdge(i,j+N,1);\n\t&#125;\n\tfor(int i &#x3D; N+1;i&lt;&#x3D;2*N;++i)&#123;\n\t\tans.AddEdge(i,N*2+1,1);\n\t&#125;\t\n\tcout&lt;&lt;ans.Maxflow(0,N*2+1);\n&#125;\n\n\n\n","slug":"ojWeek3","date":"2021-10-03T11:03:41.000Z","categories_index":"","tags_index":"网络流算法","author_index":"CT Wang"},{"id":"432e55ae1810d65c004161da271a9110","title":"被我忽悠着写博客的大佬的网站也建立好了～","content":"\n\n\n\n\n\n\n\n\n/撒花/撒花/撒花\n一个大佬的站点刚刚建立，大家快去康康\n","slug":"congra","date":"2021-10-03T06:49:12.000Z","categories_index":"","tags_index":"友站信息","author_index":"CT Wang"},{"id":"4b90cd80f00a704a2726658058c8f1d8","title":"日更吐槽","content":"\n\n\n\n\n\n\n\n\n10.2今日csapp看到进程相关的内容，里面有意思的一点是内核发送信号给进程的时候，同一种类型只会有一个pending signal，当一个新的pending signal被传来的时候，当前的pending signal就会被简单的丢弃掉。 也就是当你在做手头的东西的时候（用户模式），传来了处理紧急ddl的信号（异常响应，还未处理，属于pending状态），如果此时出现了另一个ddl（又一个pending-signal），你的第一个ddl会被错过（丢弃）。 (过于常见了属于是)\n\n\n\n\n\n\n\n\n\n10.3尝试加入访客ip的功能，意料之中的失败了 呜呜\n","slug":"daily-updated","date":"2021-10-02T12:15:52.000Z","categories_index":"","tags_index":"daily","author_index":"CT Wang"},{"id":"2f23fe7ba0abdac5dd935a1b552d8d91","title":"并不知道写什么反正先拿来测试的blog","content":"哈哈，放这个blog莫名其妙把首页的给顶下来了 吐了\n\n\n\n\n\n\n\n\n\n10.2 5:07 pm发现了从后面几个分区互相切换会出bug，暂时可以通过像先从友链分区回主页再进比如手写笔记分区这样的方式解决(已通过改绝对路径解决，可以正常使用了)\n\n\n\n\n\n\n\n\n\n10.2 5.11 pm添加手动播放bgm功能，等学会自动播放后会添加进各个blog里（目前只会手动bgm\n\n\n\n\n\n\n\n\n\n\n\n预告一下，想在blog里实现账号注册与评论的功能，但是可能得先去看一点后端的东西，先鸽着争取十一结束前发布第一个技术型博客文，可能是这周的问求的网络流算法之类的（万一ddl赶不完就鸽掉求一波网站收藏呜呜\n","slug":"My-first-blog","date":"2021-10-02T08:27:55.000Z","categories_index":"","tags_index":"“useless”","author_index":"CT Wang"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"这是第一次使用hexo在Github上建立个人blog，使用的是一个叫Aurora的主题，对这方面完全不懂所以可能经常会鸽功能。\n最近在做ics课的pa所以等课程结束会把实验日志挂上来，应该还是很有意思的（由于学术诚信问题不能现在直接挂上\n\n\n\n\n\n\n\n\n\n这是PA网站：https://nju-projectn.github.io/ics-pa-gitbook/ics2021/\n每周问题求解课程的OJ题我会尽量把题解放上来，因为很多时候不写出来其实自己也有点一知半解的。\n不定期分享恰饭照片\n（等攒够钱一定买域名挂上来解决GitHub访问慢的问题，敬请期待）\n","slug":"hello-world","date":"2021-10-02T07:34:55.000Z","categories_index":"","tags_index":"基础说明","author_index":"CT Wang"}]