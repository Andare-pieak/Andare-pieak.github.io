{"title":"Fast exact shortest-path distance queries on large networks by pruned landmark labeling","uid":"638d9a6960c17fae8271759ba6cf7538","slug":"paper-intro","date":"2021-10-04T08:34:10.000Z","updated":"2021-10-04T09:01:03.074Z","comments":true,"path":"api/articles/paper-intro.json","keywords":null,"cover":null,"content":"<p><a href=\"https://doi.org/10.1145/2463676.2465315\">这里</a>是第一次问题求解课要求精读的论文。</p>\n<p>趁着刚弄好博客还没忘记内容再把得到的知识分享出来。如有理解偏差，还请理解，也更希望能在评论区指出。</p>\n<p>首先需要解决的问题很明确</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 给定一张图G，要求能够快速查询两点之间的距离。</p></blockquote>\n<p>目前已有的算法可以分为两类，一种是exact methods，一种是approximate methods</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Exact methods: 大多基于2-hop cover的框架，其中的2-hop distance labeling运用也十分广泛，即对图上的点v，都优先求出一个标记L(v)，L(v)是一个元素为(u , d( u, v) )的集合，当我们在预处理求完L(v)后，即可在query(s ,t) 的时候直接通过L(s)和L(t)来确定最短路的长度，如果使用位优化则可以在O(1)的时间得到结论，而不需要进行一次在线的单源最短路计算，从而降低了查询的时间，也减少了存储的要求。(2-hop cover 出自于 ‘Reachability and distance queries via 2-hop labels’这篇论文，2-hop distance labeling也是其中所提到的一种方法)</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Approximate methods: 准确的方法往往很难处理大规模的数据，因而就出现了利用一定的估计来降低时间的算法，主流的方法是landmark-based approach,即在图G上选取V的子集L作为landmark，然后计算出L和V中所有的点的距离，然后需要查询u,v的距离的时候计算出最小的d(u,l)+d(v,l)即可进行估算，但是可以看出这个算法对于求原本距离很小的点会很不精确。</p></blockquote>\n<p>很容易发现，exact methods的计算存在优化的空间(离线计算时)，而landmark labeling的方式可以被优化的更加精确，于是作者巧妙的利用一种剪枝bfs方式把两种方式结合在了一起，也就是所说的 pruned landmark labeling。</p>\n<p>首先，为了利于方便说明，作者假设问题的条件是无向无权图，在有权的条件下dijkstra就可以，有向的情况也很好推广到，在这篇博客里就不过多叙述。</p>\n<p>一个很显然的想法是我们对每个点都去跑一次bfs(可以假定一个顺序)，这样就能算出来所有的label，当然时间和空间开销都很大。</p>\n<p>然后一个显然的优化是可以利用剪枝的方式不去bfs重复的边，当然需要证明的有两点，一个是这种情况下最后得到的label能够覆盖所有的查询，另一个是这样剪枝之后得到的结果是正确的。正确性的证明可以在论文中自行阅读。</p>\n<p>于是我们按照v<sub>1</sub>、v<sub>2</sub>、v<sub>3</sub>…v<sub>n</sub>的顺序进行bfs，然后进行剪枝，剪枝的方式是如果此前访问到这个点的结果导致在当前访问这个点时，查询到的长度小于等于当前bfs出的dis，我们就可以把这个点给剪掉。</p>\n<p>然后我们来分析这样一种剪枝的方式，会神奇的发现，当我们运行到第k次的时候，恰巧进行的就是大小为k的landmark，这也是pruned landmark labeling这个名字的由来之一。</p>\n<p>通过这样的剪枝，我们发现存储的空间(label的个数)，运行的时间(bfs的次数)，都得到的有效的优化。同时在dataset里的验证效果也非常的好。</p>\n<p>在文章的后半部分，作者提出了另一个神奇的优化方法：在bfs的过程中使用bit-parallel labeling的方式。 通过使用位运算将一些查询的时间变为O(1). 由于在blog表述起来不太直观，加上笔者还没学会怎么用markdown作图，因而有兴趣的读者可以在论文中自行阅读。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>综上,从整体来说，本篇文章的创新之处在于很好的融合了已有的几种策略，把不同的思想给融合到一个算法中，算法的实现也不太依赖于很复杂的架构因而有很小的常数因子。而其中先利用landmark的思想进行比较朴素的BFS再进行剪枝优化，并同时意识到一开始的不经过剪枝的部分也可以通过bit-parallel的方式进行优化的思路值得学习。</p></blockquote>\n","feature":true,"text":"这里是第一次问题求解课要求精读的论文。 趁着刚弄好博客还没忘记内容再把得到的知识分享出来。如有理解偏差，还请理解，也更希望能在评论区指出。 首先需要解决的问题很明确 给定一张图G，要求能够快速查询两点之间的距离。 目前已有的算法可以分为两类，一种是exact methods，一种...","link":"","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"最短路问题","slug":"最短路问题","count":1,"path":"api/categories/最短路问题.json"},{"name":"land-mark-labeling","slug":"最短路问题/land-mark-labeling","count":1,"path":"api/categories/最短路问题/land-mark-labeling.json"}],"tags":[{"name":"论文导读","slug":"论文导读","count":1,"path":"api/tags/论文导读.json"}],"toc":"","author":{"name":"CT Wang","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic/f4/66/ee/f466ee52242e3f89003521dfd97357e4.jpg","link":"/","description":"萌新程序员 <br /> 经典菜狗","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"ojWeek4","uid":"f961bb942d7e1f4fc29054a4a438aa31","slug":"ojWeek4","date":"2021-10-03T11:03:41.000Z","updated":"2021-10-04T02:49:49.912Z","comments":true,"path":"api/articles/ojWeek4.json","keywords":null,"cover":"https://cdn.magdeleine.co/wp-content/uploads/2018/07/IMG_4861-1-2-1400x933.jpg","text":" T1: Acesrc’s Bizarre Adventure题目描述 ： 在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc,解决下面的问题:在一个二维平面上，有N个红色的点和N个蓝色的点。其中第i个红色的点的坐标是 (ai,bi) ,...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"10 mins."},"categories":[{"name":"算法","slug":"算法","count":1,"path":"api/categories/算法.json"},{"name":"OJ","slug":"算法/OJ","count":1,"path":"api/categories/算法/OJ.json"},{"name":"网络流","slug":"算法/OJ/网络流","count":1,"path":"api/categories/算法/OJ/网络流.json"}],"tags":[{"name":"网络流算法","slug":"网络流算法","count":1,"path":"api/tags/网络流算法.json"}],"author":{"name":"CT Wang","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic/f4/66/ee/f466ee52242e3f89003521dfd97357e4.jpg","link":"/","description":"萌新程序员 <br /> 经典菜狗","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}