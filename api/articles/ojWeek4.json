{"title":"ojWeek4","uid":"f961bb942d7e1f4fc29054a4a438aa31","slug":"ojWeek4","date":"2021-10-03T11:03:41.000Z","updated":"2021-10-04T02:47:44.929Z","comments":true,"path":"api/articles/ojWeek4.json","keywords":null,"cover":"https://cdn.magdeleine.co/wp-content/uploads/2018/07/IMG_4861-1-2-1400x933.jpg","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=191171&auto=1&height=66\"></iframe>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>T1: Acesrc’s Bizarre Adventure<br>题目描述 ： 在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc,解决下面的问题:<br>在一个二维平面上，有N个红色的点和N个蓝色的点。其中第i个红色的点的坐标是 (a<sub>i</sub>,b<sub>i</sub>) ,第i和蓝色点的坐标为 (c<sub>i</sub>,d<sub>i</sub>).<br>Acesrc每次可以选择平面上一个红色的点和一个蓝色的点，如果这两个点满足红色的点的x坐标小于蓝色的点的x坐标，且红色的点的y坐标小于蓝色的点的y坐标. 那么Acesrc就可以同时将这两个点从平面上移除，并发动一次秘技·波纹疾走。<br>现在Acesrc想要知道，对于给定的一共2N个点和它们各自的坐标，他最多可以发动几次秘技·波纹疾走?<br>1 &lt;= N &lt;= 100</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>题目分析： 这道题看起来是一道典型的最大二分匹配的题，需要利用本周问题求解课程的网络流算法<br>即首先分成两个集合，然后把能连的边连上（秘技），然后权值为1，跑一次最大流算法即可。<br>此处可以参考<a href=\"https://oi-wiki.org/graph/flow/max-flow/\">oi-wiki</a>所给出的dinic算法的实现<br>worst-case的时间复杂度为O(V<sup>2</sup> E), 是可以接受的.<br>特别的，对于二分图匹配的复杂度为O(E V<sup>1/2</sup>)</p></blockquote>\n<details class=\"custom-details\">\n<summary>Click to see source code</summary>\n<p>AC代码如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define maxn 250\n#define INF 0x3f3f3f3f\n\nstruct Edge &#123;\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  int n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;int&gt; G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) &#123;\n    for (int i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(int from, int to, int cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;int&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (int i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  int DFS(int x, int a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    int flow &#x3D; 0, f;\n    for (int&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n  int Maxflow(int s, int t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    int flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;\n\nstruct point&#123;\n\tint x,y;\n&#125;R[105],B[105];\n\nint main()&#123;\n\tint N;\n\tcin&gt;&gt;N;\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tcin&gt;&gt;R[i].x;\n\t\tcin&gt;&gt;R[i].y;\n\t&#125;\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tcin&gt;&gt;B[i].x;\n\t\tcin&gt;&gt;B[i].y;\n\t&#125;\n\t\n\tDinic ans;\n\tans.init(N*2+2);\n\tfor(int i &#x3D; 1;i&lt;&#x3D;N;++i)&#123;\n\t\tans.AddEdge(0,i,1);\t\n\t\tfor(int j &#x3D; 1;j&lt;&#x3D;N;++j)\n\t\t\tif(R[i].x&lt;B[j].x&amp;&amp;R[i].y&lt;B[j].y)\n\t\t\t\tans.AddEdge(i,j+N,1);\n\t&#125;\n\tfor(int i &#x3D; N+1;i&lt;&#x3D;2*N;++i)&#123;\n\t\tans.AddEdge(i,N*2+1,1);\n\t&#125;\t\n\tcout&lt;&lt;ans.Maxflow(0,N*2+1);\n&#125;</code></pre>\n\n</p>\n</details>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=402073807&auto=1&height=66\"></iframe>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>T2: Acesrc Doesn’t Want To Bite The Dust<br>在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc解决下面的问题:<br>Acesrc得到了n个二次函数，其中第i个二次函数是f<sub>i</sub>(x)=a<sub>i</sub>x<sup>2</sup>+b<sub>i</sub>x+c<sub>i</sub><br>x<sub>i</sub>的取值范围为l<sub>i</sub>&lt;=x<sub>i</sub>&lt;=r<sub>i</sub>，x<sub>i</sub>为整数<br>除此之外Acesrc还受到了m个限制,每个限制都是形如x<sub>u</sub>&lt;=x<sub>v</sub>+d的形式，其中u和v是不同函数的编号，d是一个整数<br>Acesrc需要知道在这样的限制下所有函数的和的最大值为多少，如果失败会得到“败者食尘”的惩罚，你能帮帮他吗？</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>题目分析：据大佬所说，yjh开始放oi省选难度的题了，就很离谱。（这题做了很长时间，很恶心）<br>r<sub>i</sub>-l<sub>i</sub>的范围为0-200，n最大为50，如果直接莽着表示流的话肯定会炸。<br>网络流问题的难点也恰好在建模上，提示是使用最小割的思想。<br>我们考虑一种神奇的构造方式，首先考虑s和t作为源头和最后的节点，对于每一个函数我们考虑x所有可取的点，连接s与最小的那个以及最大的那个与t，并把中间的按从小到大的顺序连接，权值设为一个bias-f值，（因为最小割求最大-&gt;取负，为了计算方便加上一个bias），如果没有m个限制的话，此时我们可以直接通过运行最大流算法得到最小割值，这是显然的。<br>如果加上m个限制呢，首先说明，从s到t的一条路表示的是可以走的，因此当给出一个x<sub>u</sub>&lt;=x<sub>v</sub>+d的限制的时候，我们可以通过判断x<sub>u</sub>中所有可行的x值所能连接到的x<sub>v</sub>所形成的path而这样连接所形成的边是不可被割的，所以赋值INF，即可以通过最小割完成计算。</p></blockquote>\n<details class=\"custom-details\">\n<summary>Click to see source code</summary>\n<p><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define bias 1000005\n#define maxn 5005\n#define INF 1e9\n#define MAX_V 100005\nstruct Edge &#123;\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  int n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;int&gt; G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) &#123;\n    for (int i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(int from, int to, int cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;int&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (int i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  int DFS(int x, int a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    int flow &#x3D; 0, f;\n    for (int&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n  int Maxflow(int s, int t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    int flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;\n\nstruct f&#123;\n\tint a,b,c;\n&#125;ft[55];\nvector&lt; int &gt; pts[55];\n\nint u,v,w;\nint main()&#123;\n\tDinic ans;\n\tint n,m;\n\tcin&gt;&gt;n&gt;&gt;m;\n\tint T &#x3D; n;\n\twhile(T--)&#123;\n\t\tcin&gt;&gt;u&gt;&gt;v&gt;&gt;w;\n\t\tf tmp; tmp.a&#x3D;u,tmp.b&#x3D;v,tmp.c&#x3D;w;\n\t\tft[n-T] &#x3D; tmp;\n\t&#125;\n\tT &#x3D; n;\n\tint s &#x3D; 1,t &#x3D; 2,l &#x3D; 1;\n\tint cnt &#x3D; 3;\n\twhile(T--)&#123;\n\t\tcin&gt;&gt;u&gt;&gt;v;\n\t\tl &#x3D; 1;\n\t\tpts[n-T].push_back(u);\n\t\tpts[n-T].push_back(1);\n\t\tfor(int i &#x3D; u;i&lt;v;++i)&#123;\n\t\t\tpts[n-T].push_back(cnt);\n\t\t\tans.AddEdge(l,cnt,bias-ft[n-T].a*i*i-ft[n-T].b*i-ft[n-T].c);\n\t\t\tl &#x3D; cnt;\n\t\t\tcnt++;\n\t\t&#125;\n\t\tans.AddEdge(l,t,bias-ft[n-T].a*v*v-ft[n-T].b*v-ft[n-T].c);\n\t\tpts[n-T].push_back(cnt++);\n\t&#125;\n\tcnt--;\n\tT &#x3D; m;\n\twhile(T--)&#123;\n\t\tcin&gt;&gt;u&gt;&gt;v&gt;&gt;w;\n\t\tint start1 &#x3D; pts[u][0];\n\t\tint start2 &#x3D; pts[v][0];\n\t\tint len1 &#x3D; pts[u].size()-2;\n\t\tint len2 &#x3D; pts[v].size()-2;\n\t\tfor(int i &#x3D; 0;i&lt;len1;++i)&#123;\n\t\t\t\tif(start1+i&gt;start2+w)&#123;\n\t\t\t\t\tif(start1+i&gt;start2+w+len2-1)\tans.AddEdge(pts[u][i+1],t,INF);\n\t\t\t\t\telse \tans.AddEdge(pts[u][i+1],pts[v][start1+i-w-start2+1],INF);\n\t\t\t\t&#x2F;&#x2F;\tcout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;w&lt;&lt;&quot; &quot;&lt;&lt;pts[u][i]&lt;&lt;endl;\n\t\t\t\t&#125;\t\n\t\t&#125;\n\t&#125;\n\tprintf(&quot;%d\\n&quot;,n*bias-ans.Maxflow(1,2));\n\t\n&#125;</code></pre>\n\n</p>\n</details>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=188647&auto=1&height=66\"></iframe>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>T3 最小化<br>现在有n个只能取值为-W或W的变量w<sub>1</sub>,w<sub>2</sub>….w<sub>n</sub>, 你现在需要给这n个变量赋值，使得在满足一定限制的情况下目标函数最小。<br>目标函数：<br>有p个九元组(x<sub>i</sub>，y<sub>i</sub>,z<sub>i</sub>,a<sub>i</sub>,b<sub>i</sub>,c<sub>i</sub>,d<sub>i</sub>,e<sub>i</sub>,f<sub>i</sub>)。<br>定义第i个部分代价函数H<sub>i</sub>为：<br>H<sub>i</sub> = a<sub>i</sub> |w<sub>xi</sub>-w<sub>yi</sub>|+b<sub>i</sub> |w<sub>yi</sub>-w<sub>zi</sub>|+c<sub>i</sub> |w<sub>zi</sub>-w<sub>xi</sub>|+d<sub>i</sub> (w<sub>xi</sub>-w<sub>yi</sub>)+e<sub>i</sub> (w<sub>yi</sub>-w<sub>zi</sub>)+f<sub>i</sub> (w<sub>zi</sub>-w<sub>xi</sub>)<br>目标函数为O(w<sub>1</sub>,w<sub>2</sub>….w<sub>n</sub>) = w<sub>1</sub>+w<sub>2</sub>+….+w<sub>n</sub>+H<sub>1</sub>+H<sub>2</sub>+….+H<sub>n</sub><br>一共有q个限制，以三元组(x<sub>i</sub>,y<sub>i</sub>,r<sub>i</sub>)的形式给出：<br>若r<sub>i</sub> = 0， 则w<sub>xi</sub> &lt;= w<sub>yi</sub><br>若r<sub>i</sub> = 1， 则w<sub>xi</sub> = w<sub>yi</sub><br>若r<sub>i</sub> = 2， 则w<sub>xi</sub> &lt; w<sub>yi</sub></p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>题目分析：什么机器学习问题…（最小化函数，正则化）<br>言归正传，首先这题有多个数据点所以重新用dinic的时候不要忘了init。<br>和T2比较类似的都是有限制条件，所以可以想到用同样的方法进行最小割。 与T2不同的是这题的边的权值不好确定<br>考虑到w只能取+W和-W，那么其实只需要变成两个点然后中间连一条INF的边即可。</p></blockquote>\n<details class=\"custom-details\">\n<summary>Click to see source code</summary>\n<p>AC代码如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;bits&#x2F;stdc++.h&gt;\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\n#define bias 100000005\n#define maxn 5005\n#define INF LLONG_MAX\n#define MAX_V 100005\nstruct Edge &#123;\n  ll from, to, cap, flow;\n  Edge(ll u, ll v, ll c, ll f) : from(u), to(v), cap(c), flow(f) &#123;&#125;\n&#125;;\n\nstruct Dinic &#123;\n  ll n, m, s, t;\n  vector&lt;Edge&gt; edges;\n  vector&lt;ll&gt; G[maxn];\n  ll d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(ll n) &#123;\n    for (ll i &#x3D; 0; i &lt; n; i++) G[i].clear();\n    edges.clear();\n  &#125;\n\n  void AddEdge(ll from, ll to, ll cap) &#123;\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m &#x3D; edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  &#125;\n\n  bool BFS() &#123;\n    memset(vis, 0, sizeof(vis));\n    queue&lt;ll&gt; Q;\n    Q.push(s);\n    d[s] &#x3D; 0;\n    vis[s] &#x3D; 1;\n    while (!Q.empty()) &#123;\n      int x &#x3D; Q.front();\n      Q.pop();\n      for (ll i &#x3D; 0; i &lt; G[x].size(); i++) &#123;\n        Edge&amp; e &#x3D; edges[G[x][i]];\n        if (!vis[e.to] &amp;&amp; e.cap &gt; e.flow) &#123;\n          vis[e.to] &#x3D; 1;\n          d[e.to] &#x3D; d[x] + 1;\n          Q.push(e.to);\n        &#125;\n      &#125;\n    &#125;\n    return vis[t];\n  &#125;\n\n  ll DFS(ll x, ll a) &#123;\n    if (x &#x3D;&#x3D; t || a &#x3D;&#x3D; 0) return a;\n    ll flow &#x3D; 0, f;\n    for (ll&amp; i &#x3D; cur[x]; i &lt; G[x].size(); i++) &#123;\n      Edge&amp; e &#x3D; edges[G[x][i]];\n      if (d[x] + 1 &#x3D;&#x3D; d[e.to] &amp;&amp; (f &#x3D; DFS(e.to, min(a, e.cap - e.flow))) &gt; 0) &#123;\n        e.flow +&#x3D; f;\n        edges[G[x][i] ^ 1].flow -&#x3D; f;\n        flow +&#x3D; f;\n        a -&#x3D; f;\n        if (a &#x3D;&#x3D; 0) break;\n      &#125;\n    &#125;\n    return flow;\n  &#125;\n\n ll Maxflow(ll s, ll t) &#123;\n    this-&gt;s &#x3D; s;\n    this-&gt;t &#x3D; t;\n    ll flow &#x3D; 0;\n    while (BFS()) &#123;\n      memset(cur, 0, sizeof(cur));\n      flow +&#x3D; DFS(s, INF);\n    &#125;\n    return flow;\n  &#125;\n&#125;;Dinic ans;\nll pt[11451],ng[11451];\nvoid solve()&#123;\n\t\n\tll n,W,p,q;\n\t\tcin&gt;&gt;n&gt;&gt;W&gt;&gt;p&gt;&gt;q;\n\t\tfor(ll i &#x3D; 1;i&lt;&#x3D;n;++i) pt[i]&#x3D;1,ng[i]&#x3D;-1;\n\t\tll s &#x3D;0 ,t &#x3D;2*n+1; \n\t\tans.init(2*n+2);\n\t\tfor(ll i&#x3D;1;i&lt;&#x3D;p;++i)&#123;\n\t\t\tll x,y,z,a,b,c,d,e,f;\n\t\t\tcin&gt;&gt;x&gt;&gt;y&gt;&gt;z&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;\n\t\t\tpt[x]+&#x3D;(d-f); pt[y]+&#x3D;(e-d);pt[z]+&#x3D;(-e+f);\n\t\t\tng[x]-&#x3D;(d-f); ng[y]-&#x3D;(e-d);ng[z]-&#x3D;(-e+f);\n\t\t\tans.AddEdge(x,n+y,2*a);ans.AddEdge(y,n+x,2*a);\n\t\t\tans.AddEdge(y,n+z,2*b);ans.AddEdge(z,n+y,2*b);\n\t\t\tans.AddEdge(x,n+z,2*c);ans.AddEdge(z,n+x,2*c);\n\t\t&#125;\n\t\tfor(ll i&#x3D;1;i&lt;&#x3D;q;++i)&#123;\n\t\tll a,b,type;\n\t\tcin&gt;&gt;a&gt;&gt;b&gt;&gt;type;\n\t\tif(type&#x3D;&#x3D;0) ans.AddEdge(a,b+n,INF);\n\t\tif(type&#x3D;&#x3D;1) ans.AddEdge(a,b+n,INF),ans.AddEdge(b,a+n,INF);\n\t\tif(type&#x3D;&#x3D;2) ans.AddEdge(a,t,INF),ans.AddEdge(s,b+n,INF);\n\t\t&#125;\n\t\tfor(ll i &#x3D;1;i&lt;&#x3D;n;++i)&#123;\n\t\t\tans.AddEdge(s,i,ng[i]+bias);\n\t\t\tans.AddEdge(i,i+n,INF);\n\t\t\tans.AddEdge(i+n,t,pt[i]+bias);\n\t\t&#125;\n\t\tprintf(&quot;%lld\\n&quot;,W*(ans.Maxflow(0,2*n+1)-n*bias));\n&#125;\n\nint main()&#123;\n\tint T;\n\tcin&gt;&gt;T;\n\twhile(T--)&#123;\n\t\tsolve();\n\t&#125;\n\treturn 0;\n&#125;</code></pre>\n\n</p>\n</details>\n","feature":true,"text":" T1: Acesrc’s Bizarre Adventure题目描述 ： 在最新推出的爆款游戏《Acesrc的奇妙冒险》中，你需要协助我们机智帅气的主人公Acesrc,解决下面的问题:在一个二维平面上，有N个红色的点和N个蓝色的点。其中第i个红色的点的坐标是 (ai,bi) ,...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"10 mins."},"categories":[{"name":"算法","slug":"算法","count":1,"path":"api/categories/算法.json"},{"name":"OJ","slug":"算法/OJ","count":1,"path":"api/categories/算法/OJ.json"},{"name":"网络流","slug":"算法/OJ/网络流","count":1,"path":"api/categories/算法/OJ/网络流.json"}],"tags":[{"name":"网络流算法","slug":"网络流算法","count":1,"path":"api/tags/网络流算法.json"}],"toc":"","author":{"name":"Revliter","slug":"revliter","avatar":"","link":"","description":"Think like an artist, code like an artisan.","socials":{}},"mapped":true,"prev_post":{},"next_post":{"title":"被我忽悠着写博客的大佬的网站也建立好了～","uid":"432e55ae1810d65c004161da271a9110","slug":"congra","date":"2021-10-03T06:49:12.000Z","updated":"2021-10-04T02:32:16.181Z","comments":true,"path":"api/articles/congra.json","keywords":null,"cover":"https://cdn.magdeleine.co/wp-content/uploads/2015/02/YS4_5968_69_70-2-3-1400x933.jpg","text":" /撒花/撒花/撒花 一个大佬的站点刚刚建立，大家快去康康 ","link":"","photos":[],"count_time":{"symbolsCount":38,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"友站信息","slug":"友站信息","count":1,"path":"api/tags/友站信息.json"}],"author":{"name":"CT Wang","slug":"blog-author","avatar":"https://up.enterdesk.com/edpic/f4/66/ee/f466ee52242e3f89003521dfd97357e4.jpg","link":"/","description":"萌新程序员 <br /> 经典菜狗","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}